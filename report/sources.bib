@inproceedings{LibAFL,
  author    = {Fioraldi, Andrea and Maier, Dominik Christian and Zhang, Dongjia and Balzarotti, Davide},
  title     = {{LibAFL: A Framework to Build Modular and Reusable Fuzzers}},
  year      = {2022},
  isbn      = {9781450394505},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3548606.3560602},
  doi       = {10.1145/3548606.3560602},
  abstract  = {The release of AFL marked an important milestone in the area of software security testing, revitalizing fuzzing as a major research topic and spurring a large number of research studies that attempted to improve and evaluate the different aspects of the fuzzing pipeline.Many of these studies implemented their techniques by forking the AFL codebase. While this choice might seem appropriate at first, combining multiple forks into a single fuzzer requires a high engineering overhead, which hinders progress in the area and prevents fair and objective evaluations of different techniques. The highly fragmented landscape of the fuzzing ecosystem also prevents researchers from combining orthogonal techniques and makes it difficult for end users to adopt new prototype solutions.To tackle this problem, in this paper we propose LibAFL, a framework to build modular and reusable fuzzers. We discuss the different components generally used in fuzzing and map them to an extensible framework. LibAFL allows researchers and engineers to extend the core fuzzer pipeline and share their new components for further evaluations. As part of LibAFL, we integrated techniques from more than 20 previous works and conduct extensive experiments to show the benefit of our framework to combine and evaluate different approaches. We hope this can help to shed light on current advancements in fuzzing and provide a solid base for comparative and extensible research in the future.},
  booktitle = {{Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security}},
  pages     = {1051–1065},
  numpages  = {15},
  keywords  = {framework, fuzz testing, fuzzing},
  location  = {Los Angeles, CA, USA},
  series    = {CCS '22}
}

@online{LibAFLBook,
  title   = {{The LibAFL Fuzzing Library}},
  author  = {Fioraldi, Andrea and Maier, Dominik},
  url     = {https://aflplus.plus/libafl-book/},
  urldate = {2024-05-28}
}

@online{AFL,
  title   = {{Fuzzing}},
  author  = {Moroz, Max},
  date    = {2021-06-08},
  url     = {https://github.com/google/AFL},
  urldate = {2024-05-21}
}

@online{AFLCoreutils,
  title   = {{Fuzzing}},
  author  = {Sjöbom, Anders and Hasselberg, Adam},
  date    = {2019-04-25},
  url     = {https://github.com/adamhass/fuzzing/},
  urldate = {2024-05-21}
}

@misc{FileUtilsAnnouncement,
  author       = {MacKenzie, David J. },
  title        = {{GNU file utilities release 1.0}},
  howpublished = {Email to gnu.utils.bug Email List},
  date         = {1990-02-08},
  url          = {https://groups.google.com/g/gnu.utils.bug/c/CviP42X_hCY/m/YssXFn-JrX4J},
  urldate      = {2024-05-22}
}

@misc{TextUtilsAnnouncement,
  author       = {MacKenzie, David J. },
  title        = {{new GNU file and text utilities released}},
  howpublished = {Email to gnu.utils.bug Email List},
  date         = {1991-07-15},
  url          = {https://groups.google.com/g/gnu.utils.bug/c/iN5KuoJYRhU/m/V_6oiBAWF0EJ},
  urldate      = {2024-05-22}
}

@misc{ShellUtilsAnnouncement,
  author       = {MacKenzie, David J. },
  title        = {{GNU shell programming utilities released}},
  howpublished = {Email to gnu.utils.bug Email List},
  date         = {1991-08-22},
  url          = {https://groups.google.com/g/gnu.utils.bug/c/xpTRtuFpNQc/m/mRc_7JWZ0BYJ},
  urldate      = {2024-05-22}
}

@misc{CoreUtilsAnnouncement,
  author       = {Meyering, Jim},
  title        = {{package renamed to coreutils}},
  howpublished = {git commit},
  date         = {2003-01-13},
  url          = {https://git.savannah.gnu.org/cgit/coreutils.git/tree/README-package-renamed-to-coreutils},
  urldate      = {2024-05-22}
}

@online{CoreUtilsHomepage,
  title   = {{Coreutils - GNU core utilities}},
  author  = {Meyering, Jim and Brady, Pádraig and Voelker, Bernhard and Blake, Eric and Eggert, Paul and Gordon, Assaf},
  date    = {2020-12-23},
  url     = {https://www.gnu.org/software/coreutils/coreutils.html},
  urldate = {2024-05-22}
}

@online{Autoconf,
  title   = {{Autoconf}},
  author  = {Meyering, Jim},
  date    = {2020-12-08},
  url     = {https://www.gnu.org/software/autoconf},
  urldate = {2024-05-24}
}
@online{Automake,
  title   = {{Automake}},
  author  = {Meyering, Jim},
  date    = {2022-01-31},
  url     = {https://www.gnu.org/software/automake},
  urldate = {2024-05-24}
}

@online{GNULinux,
  title   = {{Linux and the GNU System}},
  author  = {Stallman, Richard},
  date    = {2021-11-02},
  url     = {https://www.gnu.org/gnu/linux-and-gnu.en.html},
  urldate = {2024-05-22}
}

@misc{GNUCoreUtils9.5,
  title        = {{GNU coreutils 9.5}},
  author       = {Meyering, Jim and Brady, Pádraig and Voelker, Bernhard and Blake, Eric and Eggert, Paul and Gordon, Assaf},
  url          = {https://ftp.gnu.org/gnu/coreutils/coreutils-9.5.tar.gz},
  howpublished = {Software Release},
  date         = {2024-03-28},
  urldate      = {2024-05-22}
}

@online{BusyBox,
  title   = {{BusyBox: The Swiss Army Knife of Embedded Linux}},
  url     = {https://www.busybox.net/about.html},
  urldate = {2024-05-22}
}

@online{Alpine,
  title   = {{Alpine Linux — About}},
  url     = {https://alpinelinux.org/about/},
  urldate = {2024-05-22}
}

@online{Uutils,
  title   = {{uutils}},
  url     = {https://uutils.github.io/},
  urldate = {2024-05-22}
}

@online{UutilsCoreUtils,
  title   = {{uutils — coreutils}},
  url     = {https://uutils.github.io/coreutils},
  urldate = {2024-05-22}
}
@online{SanitizerCoverage,
  title   = {{SanitizerCoverage}},
  url     = {https://clang.llvm.org/docs/SanitizerCoverage.html},
  urldate = {2024-05-28}
}

@article{UNIX,
  author     = {Miller, Barton P. and Fredriksen, Lars and So, Bryan},
  title      = {{An Empirical Study of the Reliability of UNIX Utilities}},
  year       = {1990},
  issue_date = {Dec. 1990},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {33},
  number     = {12},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/96267.96279},
  doi        = {10.1145/96267.96279},
  abstract   = {The following section describes the tools we built to test the utilities. These tools include the fuzz (random character) generator, ptyjig (to test interactive utilities), and scripts to automate the testing process. Next, we will describe the tests we performed, giving the types of input we presented to the utilities. Results from the tests will follow along with an analysis of the results, including identification and classification of the program bugs that caused the crashes. The final section presents concluding remarks, including suggestions for avoiding the types of problems detected by our study and some commentary on the bugs we found. We include an Appendix with the user manual pages for fuzz and ptyjig.},
  journal    = {Commun. ACM},
  month      = {12},
  pages      = {32–44},
  numpages   = {13}
}

@unpublished{EVA,
  author = {Valentin Huber},
  title  = {{Challenges and Mitigation Strategies in Symbolic Execution Based Fuzzing Through the Lens of Survey Papers}},
  year   = {2023},
  month  = {12},
  day    = {15},
  url    = {https://github.com/riesentoaster/review-symbolic-execution-in-fuzzing/releases/download/v1.0/Huber-Valentin-Challenges-and-Mitigation-Strategies-in-Symbolic-Execution-Based-Fuzzing-Through-the-Lens-of-Survey-Papers.pdf}
}

@unpublished{VT1,
  author = {Valentin Huber},
  title  = {{Running KLEE on GNU coreutils}},
  year   = {2024},
  month  = {02},
  day    = {13},
  url    = {https://github.com/riesentoaster/klee-coreutils-experiments/releases/download/v1.0/Huber-Valentin-running-KLEE-on-coreutils-report.pdf}
}

@article{AFLFast,
  author   = {Böhme, Marcel and Pham, Van-Thuan and Roychoudhury, Abhik},
  journal  = {IEEE Transactions on Software Engineering},
  title    = {Coverage-Based Greybox Fuzzing as Markov Chain},
  year     = {2019},
  volume   = {45},
  number   = {5},
  pages    = {489-506},
  keywords = {Schedules;Markov processes;Computer crashes;Search problems;Tools;Systematics;Vulnerability detection;fuzzing;path exploration;symbolic execution;automated testing},
  doi      = {10.1109/TSE.2017.2785841}
}

@inproceedings{MOPT,
  author    = {Chenyang Lyu and Shouling Ji and Chao Zhang and Yuwei Li and Wei-Han Lee and Yu Song and Raheem Beyah},
  title     = {{MOPT}: Optimized Mutation Scheduling for Fuzzers},
  booktitle = {28th USENIX Security Symposium (USENIX Security 19)},
  year      = {2019},
  isbn      = {978-1-939133-06-9},
  address   = {Santa Clara, CA},
  pages     = {1949--1966},
  url       = {https://www.usenix.org/conference/usenixsecurity19/presentation/lyu},
  publisher = {USENIX Association},
  month     = aug
}


@article{Demystifying,
  author     = {Mallissery, Sanoop and Wu, Yu-Sung},
  title      = {Demystify the Fuzzing Methods: A Comprehensive Survey},
  year       = {2023},
  issue_date = {March 2024},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {56},
  number     = {3},
  issn       = {0360-0300},
  url        = {https://doi.org/10.1145/3623375},
  doi        = {10.1145/3623375},
  abstract   = {Massive software applications possess complex data structures or parse complex data structures; in such cases, vulnerabilities in the software become inevitable. The vulnerabilities are the source of cyber-security threats, and discovering this before the software deployment is challenging. Fuzzing is a vulnerability discovery solution that resonates with random-mutation, feedback-driven, coverage-guided, constraint-guided, seed-scheduling, and target-oriented strategies. Each technique is wrapped beneath the black-, white-, and grey-box fuzzers to uncover diverse vulnerabilities. It consists of methods such as identifying structural information about the test cases to detect security vulnerabilities, symbolic and concrete program states to explore the unexplored locations, and full semantics of code coverage to create new test cases. We methodically examine each kind of fuzzers and contemporary fuzzers with a profound observation that addresses various research questions and systematically reviews and analyze the gaps and their solutions. Our survey comprised the recent related works on fuzzing techniques to demystify the fuzzing methods concerning the application domains and the target that, in turn, achieves higher code coverage and sound vulnerability detection.},
  journal    = {ACM Comput. Surv.},
  month      = {10},
  articleno  = {71},
  numpages   = {38},
  keywords   = {vulnerability discovery, Automated testing, fuzzing, code inspection}
}

@article{SurveyRoadmap,
  author     = {Zhu, Xiaogang and Wen, Sheng and Camtepe, Seyit and Xiang, Yang},
  title      = {Fuzzing: A Survey for Roadmap},
  year       = {2022},
  issue_date = {January 2022},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {54},
  number     = {11s},
  issn       = {0360-0300},
  url        = {https://doi.org/10.1145/3512345},
  doi        = {10.1145/3512345},
  abstract   = {Fuzz testing (fuzzing) has witnessed its prosperity in detecting security flaws recently. It generates a large number of test cases and monitors the executions for defects. Fuzzing has detected thousands of bugs and vulnerabilities in various applications. Although effective, there lacks systematic analysis of gaps faced by fuzzing. As a technique of defect detection, fuzzing is required to narrow down the gaps between the entire input space and the defect space. Without limitation on the generated inputs, the input space is infinite. However, defects are sparse in an application, which indicates that the defect space is much smaller than the entire input space. Besides, because fuzzing generates numerous test cases to repeatedly examine targets, it requires fuzzing to perform in an automatic manner. Due to the complexity of applications and defects, it is challenging to automatize the execution of diverse applications. In this article, we systematically review and analyze the gaps as well as their solutions, considering both breadth and depth. This survey can be a roadmap for both beginners and advanced developers to better understand fuzzing.},
  journal    = {ACM Comput. Surv.},
  month      = {09},
  articleno  = {230},
  numpages   = {36},
  keywords   = {automation, input space, fuzzing theory, security, Fuzz testing}
}

@online{AFLBugs,
  title   = {{The bug-o-rama trophy case}},
  author  = {Zalewski, Michal},
  url     = {https://lcamtuf.coredump.cx/afl/#bugs},
  urldate = {2024-06-03}
}

@online{AFLPlusPlus,
  title   = {{AFL++}},
  url     = {https://aflplus.plus},
  urldate = {2024-06-03}
}